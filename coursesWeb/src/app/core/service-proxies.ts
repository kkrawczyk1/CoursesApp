import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CoursesApi {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getById(id: number): Observable<SwaggerResponse<CourseDTO>> {
    let url_ = this.baseUrl + '/api/Courses/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SwaggerResponse<CourseDTO>
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SwaggerResponse<CourseDTO>
            >;
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<SwaggerResponse<CourseDTO>> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CourseDTO.fromJS(resultData200);
          return _observableOf(
            new SwaggerResponse(status, _headers, result200)
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SwaggerResponse<CourseDTO>>(
      new SwaggerResponse(status, _headers, null as any)
    );
  }

  edit(
    id: number,
    course: CourseDTO | null | undefined
  ): Observable<SwaggerResponse<number>> {
    let url_ = this.baseUrl + '/api/Courses/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(course);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEdit(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SwaggerResponse<number>
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SwaggerResponse<number>
            >;
        })
      );
  }

  protected processEdit(
    response: HttpResponseBase
  ): Observable<SwaggerResponse<number>> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(
            new SwaggerResponse(status, _headers, result200)
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SwaggerResponse<number>>(
      new SwaggerResponse(status, _headers, null as any)
    );
  }

  delete(id: number): Observable<SwaggerResponse<number>> {
    let url_ = this.baseUrl + '/api/Courses/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SwaggerResponse<number>
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SwaggerResponse<number>
            >;
        })
      );
  }

  protected processDelete(
    response: HttpResponseBase
  ): Observable<SwaggerResponse<number>> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(
            new SwaggerResponse(status, _headers, result200)
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SwaggerResponse<number>>(
      new SwaggerResponse(status, _headers, null as any)
    );
  }

  getAll(): Observable<SwaggerResponse<CourseDTO[]>> {
    let url_ = this.baseUrl + '/api/Courses';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SwaggerResponse<CourseDTO[]>
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SwaggerResponse<CourseDTO[]>
            >;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<SwaggerResponse<CourseDTO[]>> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CourseDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(
            new SwaggerResponse(status, _headers, result200)
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SwaggerResponse<CourseDTO[]>>(
      new SwaggerResponse(status, _headers, null as any)
    );
  }

  create(
    course: CourseDTO | null | undefined
  ): Observable<SwaggerResponse<number>> {
    let url_ = this.baseUrl + '/api/Courses';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(course);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SwaggerResponse<number>
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SwaggerResponse<number>
            >;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<SwaggerResponse<number>> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(
            new SwaggerResponse(status, _headers, result200)
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SwaggerResponse<number>>(
      new SwaggerResponse(status, _headers, null as any)
    );
  }
}

export class CourseDTO implements ICourseDTO {
  id!: number;
  name!: string;
  description!: string;
  subjects!: SubjectDTO[];

  constructor(data?: ICourseDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['subjects'])) {
        this.subjects = [] as any;
        for (let item of _data['subjects'])
          this.subjects!.push(SubjectDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CourseDTO {
    data = typeof data === 'object' ? data : {};
    let result = new CourseDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.subjects)) {
      data['subjects'] = [];
      for (let item of this.subjects) data['subjects'].push(item.toJSON());
    }
    return data;
  }

  clone(): CourseDTO {
    const json = this.toJSON();
    let result = new CourseDTO();
    result.init(json);
    return result;
  }
}

export interface ICourseDTO {
  id: number | null | undefined;
  name: string | undefined;
  description: string | undefined;
  subjects: SubjectDTO[] | undefined;
}

export class SubjectDTO implements ISubjectDTO {
  id!: number | string | undefined | null;
  subjectName!: string | undefined;
  subjectNumber!: number;

  constructor(data?: ISubjectDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.subjectName = _data['subjectName'];
      this.subjectNumber = _data['subjectNumber'];
    }
  }

  static fromJS(data: any): SubjectDTO {
    data = typeof data === 'object' ? data : {};
    let result = new SubjectDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['subjectName'] = this.subjectName;
    data['subjectNumber'] = this.subjectNumber;
    return data;
  }

  clone(): SubjectDTO {
    const json = this.toJSON();
    let result = new SubjectDTO();
    result.init(json);
    return result;
  }
}

export interface ISubjectDTO {
  id: number | string | undefined | null;
  subjectName: string | undefined;
  subjectNumber: number;
}

export class SwaggerResponse<TResult> {
  status: number;
  headers: { [key: string]: any };
  result: TResult;

  constructor(
    status: number,
    headers: { [key: string]: any },
    result: TResult
  ) {
    this.status = status;
    this.headers = headers;
    this.result = result;
  }
}

export class SwaggerException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  return _observableThrow(
    new SwaggerException(message, status, response, headers, result)
  );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
